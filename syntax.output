Terminals unused in grammar

   comment_une
   comment_plsr
   reel_pos
   reel_neg


État 10conflits: 1 décalage/réduction
État 68conflits: 6 réduction/réduction
État 113conflits: 4 décalage/réduction


Grammaire

    0 $accept: DEBUT $end

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    2 DECLARATION: let VARIABLE1 deux_pnts TYPE1 pnt_virgul
    3            | let idf deux_pnts TYPE2 pnt_virgul
    4            | constante idf deux_pnts TYPE1 egal VALEUR

    5 VALEUR: entier_pos
    6       | entier_neg
    7       | float_pos
    8       | float_neg

    9 VARIABLE1: idf virgul VARIABLE1
   10          | idf

   11 TYPE1: reel
   12      | entier

   13 TYPE2: corechet_ouvr TYPE1 pnt_virgul entier_pos corechet_ferm pnt_virgul

   14 INSTRUCTIONS: /* vide */
   15             | idf AFFECTATION_NOR INSTRUCTIONS
   16             | idf AFFECTATION_TAB INSTRUCTIONS
   17             | INPUT INSTRUCTIONS
   18             | OUTPUT INSTRUCTIONS
   19             | CONDITION INSTRUCTIONS
   20             | LOOP_DO INSTRUCTIONS
   21             | LOOP_FOR INSTRUCTIONS

   22 AFFECTATION_TAB: corechet_ouvr entier_pos corechet_ferm AFFECTATION_NOR

   23 AFFECTATION_NOR: affect EXPRESSION pnt_virgul

   24 EXPRESSION: parenthese_ouvr EXPRESSION parenthese_ferm
   25           | EXPRESSION OPERATEUR_ARITHM EXPRESSION
   26           | OPERAND
   27           | VALEUR

   28 OPERAND: idf
   29        | VALEUR
   30        | neg OPERAND

   31 OPERATEUR_ARITHM: add
   32                 | soustract
   33                 | division
   34                 | multipl

   35 INPUT: lire parenthese_ouvr idf parenthese_ferm pnt_virgul

   36 OUTPUT: output parenthese_ouvr DANS_OUTPUT parenthese_ferm pnt_virgul

   37 DANS_OUTPUT: chaine
   38            | idf
   39            | chaine virgul DANS_OUTPUT
   40            | idf virgul DANS_OUTPUT

   41 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm then accolade_ouvr INSTRUCTIONS accolade_ferm SINON

   42 SINON: else_cond accolade_ouvr INSTRUCTIONS accolade_ferm
   43      | /* vide */

   44 EXPRESSION_COND: OPERAND OPERATEUR_COND OPERAND
   45                | EXPRESSION_COND and EXPRESSION_COND
   46                | EXPRESSION_COND or EXPRESSION_COND

   47 OPERATEUR_COND: inf
   48               | sup
   49               | inf_ou_egal
   50               | sup_ou_egal
   51               | identiq
   52               | diff

   53 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul

   54 LOOP_FOR: boucle_for idf from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm


Terminaux, suivis des règles où ils apparaissent

$end (0) 0
error (256)
MainPrgm (258) 1
idf (259) 1 3 4 9 10 15 16 28 35 38 40 54
pnt_virgul (260) 1 2 3 13 23 35 36 53
var (261) 1
BeginPg (262) 1
accolade_ouvr (263) 1 41 42 53 54
accolade_ferm (264) 1 41 42 53 54
EndPg (265) 1
let (266) 2 3
deux_pnts (267) 2 3 4
constante (268) 4
egal (269) 4
virgul (270) 9 39 40
reel (271) 11
entier (272) 12
entier_pos (273) 5 13 22 54
corechet_ouvr (274) 13 22
corechet_ferm (275) 13 22
entier_neg (276) 6
float_pos (277) 7
float_neg (278) 8
affect (279) 23
chaine (280) 37 39
if_cond (281) 41
then (282) 41
parenthese_ferm (283) 24 35 36 41 53
parenthese_ouvr (284) 24 35 36 41 53
lire (285) 35
output (286) 36
add (287) 31
soustract (288) 32
division (289) 33
multipl (290) 34
inf (291) 47
sup (292) 48
inf_ou_egal (293) 49
sup_ou_egal (294) 50
neg (295) 30
and (296) 45
or (297) 46
diff (298) 52
boucle_for (299) 54
from (300) 54
to (301) 54
step (302) 54
boucle_do (303) 53
boucle_while (304) 53
comment_une (305)
comment_plsr (306)
else_cond (307) 42
reel_pos (308)
reel_neg (309)
identiq (310) 51


Non-terminaux, suivis des règles où ils apparaissent

$accept (56)
    à gauche: 0
DEBUT (57)
    à gauche: 1, à droite: 0
DECLARATION (58)
    à gauche: 2 3 4, à droite: 1
VALEUR (59)
    à gauche: 5 6 7 8, à droite: 4 27 29
VARIABLE1 (60)
    à gauche: 9 10, à droite: 2 9
TYPE1 (61)
    à gauche: 11 12, à droite: 2 4 13
TYPE2 (62)
    à gauche: 13, à droite: 3
INSTRUCTIONS (63)
    à gauche: 14 15 16 17 18 19 20 21, à droite: 1 15 16 17 18 19 20
    21 41 42 53 54
AFFECTATION_TAB (64)
    à gauche: 22, à droite: 16
AFFECTATION_NOR (65)
    à gauche: 23, à droite: 15 22
EXPRESSION (66)
    à gauche: 24 25 26 27, à droite: 23 24 25
OPERAND (67)
    à gauche: 28 29 30, à droite: 26 30 44
OPERATEUR_ARITHM (68)
    à gauche: 31 32 33 34, à droite: 25
INPUT (69)
    à gauche: 35, à droite: 17
OUTPUT (70)
    à gauche: 36, à droite: 18
DANS_OUTPUT (71)
    à gauche: 37 38 39 40, à droite: 36 39 40
CONDITION (72)
    à gauche: 41, à droite: 19
SINON (73)
    à gauche: 42 43, à droite: 41
EXPRESSION_COND (74)
    à gauche: 44 45 46, à droite: 41 45 46 53
OPERATEUR_COND (75)
    à gauche: 47 48 49 50 51 52, à droite: 44
LOOP_DO (76)
    à gauche: 53, à droite: 20
LOOP_FOR (77)
    à gauche: 54, à droite: 21


état 0

    0 $accept: . DEBUT $end

    MainPrgm  décalage et aller à l'état 1

    DEBUT  aller à l'état 2


état 1

    1 DEBUT: MainPrgm . idf pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    idf  décalage et aller à l'état 3


état 2

    0 $accept: DEBUT . $end

    $end  décalage et aller à l'état 4


état 3

    1 DEBUT: MainPrgm idf . pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    pnt_virgul  décalage et aller à l'état 5


état 4

    0 $accept: DEBUT $end .

    $défaut  accepter


état 5

    1 DEBUT: MainPrgm idf pnt_virgul . var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    var  décalage et aller à l'état 6


état 6

    1 DEBUT: MainPrgm idf pnt_virgul var . DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    let        décalage et aller à l'état 7
    constante  décalage et aller à l'état 8

    DECLARATION  aller à l'état 9


état 7

    2 DECLARATION: let . VARIABLE1 deux_pnts TYPE1 pnt_virgul
    3            | let . idf deux_pnts TYPE2 pnt_virgul

    idf  décalage et aller à l'état 10

    VARIABLE1  aller à l'état 11


état 8

    4 DECLARATION: constante . idf deux_pnts TYPE1 egal VALEUR

    idf  décalage et aller à l'état 12


état 9

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION . BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    BeginPg  décalage et aller à l'état 13


état 10

    3 DECLARATION: let idf . deux_pnts TYPE2 pnt_virgul
    9 VARIABLE1: idf . virgul VARIABLE1
   10          | idf .

    deux_pnts  décalage et aller à l'état 14
    virgul     décalage et aller à l'état 15

    deux_pnts  [réduction par utilisation de la règle 10 (VARIABLE1)]


état 11

    2 DECLARATION: let VARIABLE1 . deux_pnts TYPE1 pnt_virgul

    deux_pnts  décalage et aller à l'état 16


état 12

    4 DECLARATION: constante idf . deux_pnts TYPE1 egal VALEUR

    deux_pnts  décalage et aller à l'état 17


état 13

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg . accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    accolade_ouvr  décalage et aller à l'état 18


état 14

    3 DECLARATION: let idf deux_pnts . TYPE2 pnt_virgul

    corechet_ouvr  décalage et aller à l'état 19

    TYPE2  aller à l'état 20


état 15

    9 VARIABLE1: idf virgul . VARIABLE1

    idf  décalage et aller à l'état 21

    VARIABLE1  aller à l'état 22


état 16

    2 DECLARATION: let VARIABLE1 deux_pnts . TYPE1 pnt_virgul

    reel    décalage et aller à l'état 23
    entier  décalage et aller à l'état 24

    TYPE1  aller à l'état 25


état 17

    4 DECLARATION: constante idf deux_pnts . TYPE1 egal VALEUR

    reel    décalage et aller à l'état 23
    entier  décalage et aller à l'état 24

    TYPE1  aller à l'état 26


état 18

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg accolade_ouvr . INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    idf         décalage et aller à l'état 27
    if_cond     décalage et aller à l'état 28
    lire        décalage et aller à l'état 29
    output      décalage et aller à l'état 30
    boucle_for  décalage et aller à l'état 31
    boucle_do   décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 33
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 19

   13 TYPE2: corechet_ouvr . TYPE1 pnt_virgul entier_pos corechet_ferm pnt_virgul

    reel    décalage et aller à l'état 23
    entier  décalage et aller à l'état 24

    TYPE1  aller à l'état 39


état 20

    3 DECLARATION: let idf deux_pnts TYPE2 . pnt_virgul

    pnt_virgul  décalage et aller à l'état 40


état 21

    9 VARIABLE1: idf . virgul VARIABLE1
   10          | idf .

    virgul  décalage et aller à l'état 15

    $défaut  réduction par utilisation de la règle 10 (VARIABLE1)


état 22

    9 VARIABLE1: idf virgul VARIABLE1 .

    $défaut  réduction par utilisation de la règle 9 (VARIABLE1)


état 23

   11 TYPE1: reel .

    $défaut  réduction par utilisation de la règle 11 (TYPE1)


état 24

   12 TYPE1: entier .

    $défaut  réduction par utilisation de la règle 12 (TYPE1)


état 25

    2 DECLARATION: let VARIABLE1 deux_pnts TYPE1 . pnt_virgul

    pnt_virgul  décalage et aller à l'état 41


état 26

    4 DECLARATION: constante idf deux_pnts TYPE1 . egal VALEUR

    egal  décalage et aller à l'état 42


état 27

   15 INSTRUCTIONS: idf . AFFECTATION_NOR INSTRUCTIONS
   16             | idf . AFFECTATION_TAB INSTRUCTIONS

    corechet_ouvr  décalage et aller à l'état 43
    affect         décalage et aller à l'état 44

    AFFECTATION_TAB  aller à l'état 45
    AFFECTATION_NOR  aller à l'état 46


état 28

   41 CONDITION: if_cond . parenthese_ouvr EXPRESSION_COND parenthese_ferm then accolade_ouvr INSTRUCTIONS accolade_ferm SINON

    parenthese_ouvr  décalage et aller à l'état 47


état 29

   35 INPUT: lire . parenthese_ouvr idf parenthese_ferm pnt_virgul

    parenthese_ouvr  décalage et aller à l'état 48


état 30

   36 OUTPUT: output . parenthese_ouvr DANS_OUTPUT parenthese_ferm pnt_virgul

    parenthese_ouvr  décalage et aller à l'état 49


état 31

   54 LOOP_FOR: boucle_for . idf from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    idf  décalage et aller à l'état 50


état 32

   53 LOOP_DO: boucle_do . accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul

    accolade_ouvr  décalage et aller à l'état 51


état 33

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS . accolade_ferm EndPg pnt_virgul

    accolade_ferm  décalage et aller à l'état 52


état 34

   17 INSTRUCTIONS: INPUT . INSTRUCTIONS

    idf         décalage et aller à l'état 27
    if_cond     décalage et aller à l'état 28
    lire        décalage et aller à l'état 29
    output      décalage et aller à l'état 30
    boucle_for  décalage et aller à l'état 31
    boucle_do   décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 53
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 35

   18 INSTRUCTIONS: OUTPUT . INSTRUCTIONS

    idf         décalage et aller à l'état 27
    if_cond     décalage et aller à l'état 28
    lire        décalage et aller à l'état 29
    output      décalage et aller à l'état 30
    boucle_for  décalage et aller à l'état 31
    boucle_do   décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 54
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 36

   19 INSTRUCTIONS: CONDITION . INSTRUCTIONS

    idf         décalage et aller à l'état 27
    if_cond     décalage et aller à l'état 28
    lire        décalage et aller à l'état 29
    output      décalage et aller à l'état 30
    boucle_for  décalage et aller à l'état 31
    boucle_do   décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 55
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 37

   20 INSTRUCTIONS: LOOP_DO . INSTRUCTIONS

    idf         décalage et aller à l'état 27
    if_cond     décalage et aller à l'état 28
    lire        décalage et aller à l'état 29
    output      décalage et aller à l'état 30
    boucle_for  décalage et aller à l'état 31
    boucle_do   décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 56
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 38

   21 INSTRUCTIONS: LOOP_FOR . INSTRUCTIONS

    idf         décalage et aller à l'état 27
    if_cond     décalage et aller à l'état 28
    lire        décalage et aller à l'état 29
    output      décalage et aller à l'état 30
    boucle_for  décalage et aller à l'état 31
    boucle_do   décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 57
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 39

   13 TYPE2: corechet_ouvr TYPE1 . pnt_virgul entier_pos corechet_ferm pnt_virgul

    pnt_virgul  décalage et aller à l'état 58


état 40

    3 DECLARATION: let idf deux_pnts TYPE2 pnt_virgul .

    $défaut  réduction par utilisation de la règle 3 (DECLARATION)


état 41

    2 DECLARATION: let VARIABLE1 deux_pnts TYPE1 pnt_virgul .

    $défaut  réduction par utilisation de la règle 2 (DECLARATION)


état 42

    4 DECLARATION: constante idf deux_pnts TYPE1 egal . VALEUR

    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62

    VALEUR  aller à l'état 63


état 43

   22 AFFECTATION_TAB: corechet_ouvr . entier_pos corechet_ferm AFFECTATION_NOR

    entier_pos  décalage et aller à l'état 64


état 44

   23 AFFECTATION_NOR: affect . EXPRESSION pnt_virgul

    idf              décalage et aller à l'état 65
    entier_pos       décalage et aller à l'état 59
    entier_neg       décalage et aller à l'état 60
    float_pos        décalage et aller à l'état 61
    float_neg        décalage et aller à l'état 62
    parenthese_ouvr  décalage et aller à l'état 66
    neg              décalage et aller à l'état 67

    VALEUR      aller à l'état 68
    EXPRESSION  aller à l'état 69
    OPERAND     aller à l'état 70


état 45

   16 INSTRUCTIONS: idf AFFECTATION_TAB . INSTRUCTIONS

    idf         décalage et aller à l'état 27
    if_cond     décalage et aller à l'état 28
    lire        décalage et aller à l'état 29
    output      décalage et aller à l'état 30
    boucle_for  décalage et aller à l'état 31
    boucle_do   décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 71
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 46

   15 INSTRUCTIONS: idf AFFECTATION_NOR . INSTRUCTIONS

    idf         décalage et aller à l'état 27
    if_cond     décalage et aller à l'état 28
    lire        décalage et aller à l'état 29
    output      décalage et aller à l'état 30
    boucle_for  décalage et aller à l'état 31
    boucle_do   décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 72
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 47

   41 CONDITION: if_cond parenthese_ouvr . EXPRESSION_COND parenthese_ferm then accolade_ouvr INSTRUCTIONS accolade_ferm SINON

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62
    neg         décalage et aller à l'état 67

    VALEUR           aller à l'état 73
    OPERAND          aller à l'état 74
    EXPRESSION_COND  aller à l'état 75


état 48

   35 INPUT: lire parenthese_ouvr . idf parenthese_ferm pnt_virgul

    idf  décalage et aller à l'état 76


état 49

   36 OUTPUT: output parenthese_ouvr . DANS_OUTPUT parenthese_ferm pnt_virgul

    idf     décalage et aller à l'état 77
    chaine  décalage et aller à l'état 78

    DANS_OUTPUT  aller à l'état 79


état 50

   54 LOOP_FOR: boucle_for idf . from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    from  décalage et aller à l'état 80


état 51

   53 LOOP_DO: boucle_do accolade_ouvr . INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul

    idf         décalage et aller à l'état 27
    if_cond     décalage et aller à l'état 28
    lire        décalage et aller à l'état 29
    output      décalage et aller à l'état 30
    boucle_for  décalage et aller à l'état 31
    boucle_do   décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 81
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 52

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm . EndPg pnt_virgul

    EndPg  décalage et aller à l'état 82


état 53

   17 INSTRUCTIONS: INPUT INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 17 (INSTRUCTIONS)


état 54

   18 INSTRUCTIONS: OUTPUT INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 18 (INSTRUCTIONS)


état 55

   19 INSTRUCTIONS: CONDITION INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 19 (INSTRUCTIONS)


état 56

   20 INSTRUCTIONS: LOOP_DO INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 20 (INSTRUCTIONS)


état 57

   21 INSTRUCTIONS: LOOP_FOR INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 21 (INSTRUCTIONS)


état 58

   13 TYPE2: corechet_ouvr TYPE1 pnt_virgul . entier_pos corechet_ferm pnt_virgul

    entier_pos  décalage et aller à l'état 83


état 59

    5 VALEUR: entier_pos .

    $défaut  réduction par utilisation de la règle 5 (VALEUR)


état 60

    6 VALEUR: entier_neg .

    $défaut  réduction par utilisation de la règle 6 (VALEUR)


état 61

    7 VALEUR: float_pos .

    $défaut  réduction par utilisation de la règle 7 (VALEUR)


état 62

    8 VALEUR: float_neg .

    $défaut  réduction par utilisation de la règle 8 (VALEUR)


état 63

    4 DECLARATION: constante idf deux_pnts TYPE1 egal VALEUR .

    $défaut  réduction par utilisation de la règle 4 (DECLARATION)


état 64

   22 AFFECTATION_TAB: corechet_ouvr entier_pos . corechet_ferm AFFECTATION_NOR

    corechet_ferm  décalage et aller à l'état 84


état 65

   28 OPERAND: idf .

    $défaut  réduction par utilisation de la règle 28 (OPERAND)


état 66

   24 EXPRESSION: parenthese_ouvr . EXPRESSION parenthese_ferm

    idf              décalage et aller à l'état 65
    entier_pos       décalage et aller à l'état 59
    entier_neg       décalage et aller à l'état 60
    float_pos        décalage et aller à l'état 61
    float_neg        décalage et aller à l'état 62
    parenthese_ouvr  décalage et aller à l'état 66
    neg              décalage et aller à l'état 67

    VALEUR      aller à l'état 68
    EXPRESSION  aller à l'état 85
    OPERAND     aller à l'état 70


état 67

   30 OPERAND: neg . OPERAND

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62
    neg         décalage et aller à l'état 67

    VALEUR   aller à l'état 73
    OPERAND  aller à l'état 86


état 68

   27 EXPRESSION: VALEUR .
   29 OPERAND: VALEUR .

    pnt_virgul       réduction par utilisation de la règle 27 (EXPRESSION)
    pnt_virgul       [réduction par utilisation de la règle 29 (OPERAND)]
    parenthese_ferm  réduction par utilisation de la règle 27 (EXPRESSION)
    parenthese_ferm  [réduction par utilisation de la règle 29 (OPERAND)]
    add              réduction par utilisation de la règle 27 (EXPRESSION)
    add              [réduction par utilisation de la règle 29 (OPERAND)]
    soustract        réduction par utilisation de la règle 27 (EXPRESSION)
    soustract        [réduction par utilisation de la règle 29 (OPERAND)]
    division         réduction par utilisation de la règle 27 (EXPRESSION)
    division         [réduction par utilisation de la règle 29 (OPERAND)]
    multipl          réduction par utilisation de la règle 27 (EXPRESSION)
    multipl          [réduction par utilisation de la règle 29 (OPERAND)]
    $défaut          réduction par utilisation de la règle 27 (EXPRESSION)


état 69

   23 AFFECTATION_NOR: affect EXPRESSION . pnt_virgul
   25 EXPRESSION: EXPRESSION . OPERATEUR_ARITHM EXPRESSION

    pnt_virgul  décalage et aller à l'état 87
    add         décalage et aller à l'état 88
    soustract   décalage et aller à l'état 89
    division    décalage et aller à l'état 90
    multipl     décalage et aller à l'état 91

    OPERATEUR_ARITHM  aller à l'état 92


état 70

   26 EXPRESSION: OPERAND .

    $défaut  réduction par utilisation de la règle 26 (EXPRESSION)


état 71

   16 INSTRUCTIONS: idf AFFECTATION_TAB INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)


état 72

   15 INSTRUCTIONS: idf AFFECTATION_NOR INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 15 (INSTRUCTIONS)


état 73

   29 OPERAND: VALEUR .

    $défaut  réduction par utilisation de la règle 29 (OPERAND)


état 74

   44 EXPRESSION_COND: OPERAND . OPERATEUR_COND OPERAND

    inf          décalage et aller à l'état 93
    sup          décalage et aller à l'état 94
    inf_ou_egal  décalage et aller à l'état 95
    sup_ou_egal  décalage et aller à l'état 96
    diff         décalage et aller à l'état 97
    identiq      décalage et aller à l'état 98

    OPERATEUR_COND  aller à l'état 99


état 75

   41 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND . parenthese_ferm then accolade_ouvr INSTRUCTIONS accolade_ferm SINON
   45 EXPRESSION_COND: EXPRESSION_COND . and EXPRESSION_COND
   46                | EXPRESSION_COND . or EXPRESSION_COND

    parenthese_ferm  décalage et aller à l'état 100
    and              décalage et aller à l'état 101
    or               décalage et aller à l'état 102


état 76

   35 INPUT: lire parenthese_ouvr idf . parenthese_ferm pnt_virgul

    parenthese_ferm  décalage et aller à l'état 103


état 77

   38 DANS_OUTPUT: idf .
   40            | idf . virgul DANS_OUTPUT

    virgul  décalage et aller à l'état 104

    $défaut  réduction par utilisation de la règle 38 (DANS_OUTPUT)


état 78

   37 DANS_OUTPUT: chaine .
   39            | chaine . virgul DANS_OUTPUT

    virgul  décalage et aller à l'état 105

    $défaut  réduction par utilisation de la règle 37 (DANS_OUTPUT)


état 79

   36 OUTPUT: output parenthese_ouvr DANS_OUTPUT . parenthese_ferm pnt_virgul

    parenthese_ferm  décalage et aller à l'état 106


état 80

   54 LOOP_FOR: boucle_for idf from . entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    entier_pos  décalage et aller à l'état 107


état 81

   53 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS . accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul

    accolade_ferm  décalage et aller à l'état 108


état 82

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg . pnt_virgul

    pnt_virgul  décalage et aller à l'état 109


état 83

   13 TYPE2: corechet_ouvr TYPE1 pnt_virgul entier_pos . corechet_ferm pnt_virgul

    corechet_ferm  décalage et aller à l'état 110


état 84

   22 AFFECTATION_TAB: corechet_ouvr entier_pos corechet_ferm . AFFECTATION_NOR

    affect  décalage et aller à l'état 44

    AFFECTATION_NOR  aller à l'état 111


état 85

   24 EXPRESSION: parenthese_ouvr EXPRESSION . parenthese_ferm
   25           | EXPRESSION . OPERATEUR_ARITHM EXPRESSION

    parenthese_ferm  décalage et aller à l'état 112
    add              décalage et aller à l'état 88
    soustract        décalage et aller à l'état 89
    division         décalage et aller à l'état 90
    multipl          décalage et aller à l'état 91

    OPERATEUR_ARITHM  aller à l'état 92


état 86

   30 OPERAND: neg OPERAND .

    $défaut  réduction par utilisation de la règle 30 (OPERAND)


état 87

   23 AFFECTATION_NOR: affect EXPRESSION pnt_virgul .

    $défaut  réduction par utilisation de la règle 23 (AFFECTATION_NOR)


état 88

   31 OPERATEUR_ARITHM: add .

    $défaut  réduction par utilisation de la règle 31 (OPERATEUR_ARITHM)


état 89

   32 OPERATEUR_ARITHM: soustract .

    $défaut  réduction par utilisation de la règle 32 (OPERATEUR_ARITHM)


état 90

   33 OPERATEUR_ARITHM: division .

    $défaut  réduction par utilisation de la règle 33 (OPERATEUR_ARITHM)


état 91

   34 OPERATEUR_ARITHM: multipl .

    $défaut  réduction par utilisation de la règle 34 (OPERATEUR_ARITHM)


état 92

   25 EXPRESSION: EXPRESSION OPERATEUR_ARITHM . EXPRESSION

    idf              décalage et aller à l'état 65
    entier_pos       décalage et aller à l'état 59
    entier_neg       décalage et aller à l'état 60
    float_pos        décalage et aller à l'état 61
    float_neg        décalage et aller à l'état 62
    parenthese_ouvr  décalage et aller à l'état 66
    neg              décalage et aller à l'état 67

    VALEUR      aller à l'état 68
    EXPRESSION  aller à l'état 113
    OPERAND     aller à l'état 70


état 93

   47 OPERATEUR_COND: inf .

    $défaut  réduction par utilisation de la règle 47 (OPERATEUR_COND)


état 94

   48 OPERATEUR_COND: sup .

    $défaut  réduction par utilisation de la règle 48 (OPERATEUR_COND)


état 95

   49 OPERATEUR_COND: inf_ou_egal .

    $défaut  réduction par utilisation de la règle 49 (OPERATEUR_COND)


état 96

   50 OPERATEUR_COND: sup_ou_egal .

    $défaut  réduction par utilisation de la règle 50 (OPERATEUR_COND)


état 97

   52 OPERATEUR_COND: diff .

    $défaut  réduction par utilisation de la règle 52 (OPERATEUR_COND)


état 98

   51 OPERATEUR_COND: identiq .

    $défaut  réduction par utilisation de la règle 51 (OPERATEUR_COND)


état 99

   44 EXPRESSION_COND: OPERAND OPERATEUR_COND . OPERAND

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62
    neg         décalage et aller à l'état 67

    VALEUR   aller à l'état 73
    OPERAND  aller à l'état 114


état 100

   41 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm . then accolade_ouvr INSTRUCTIONS accolade_ferm SINON

    then  décalage et aller à l'état 115


état 101

   45 EXPRESSION_COND: EXPRESSION_COND and . EXPRESSION_COND

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62
    neg         décalage et aller à l'état 67

    VALEUR           aller à l'état 73
    OPERAND          aller à l'état 74
    EXPRESSION_COND  aller à l'état 116


état 102

   46 EXPRESSION_COND: EXPRESSION_COND or . EXPRESSION_COND

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62
    neg         décalage et aller à l'état 67

    VALEUR           aller à l'état 73
    OPERAND          aller à l'état 74
    EXPRESSION_COND  aller à l'état 117


état 103

   35 INPUT: lire parenthese_ouvr idf parenthese_ferm . pnt_virgul

    pnt_virgul  décalage et aller à l'état 118


état 104

   40 DANS_OUTPUT: idf virgul . DANS_OUTPUT

    idf     décalage et aller à l'état 77
    chaine  décalage et aller à l'état 78

    DANS_OUTPUT  aller à l'état 119


état 105

   39 DANS_OUTPUT: chaine virgul . DANS_OUTPUT

    idf     décalage et aller à l'état 77
    chaine  décalage et aller à l'état 78

    DANS_OUTPUT  aller à l'état 120


état 106

   36 OUTPUT: output parenthese_ouvr DANS_OUTPUT parenthese_ferm . pnt_virgul

    pnt_virgul  décalage et aller à l'état 121


état 107

   54 LOOP_FOR: boucle_for idf from entier_pos . to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    to  décalage et aller à l'état 122


état 108

   53 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm . boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul

    boucle_while  décalage et aller à l'état 123


état 109

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul .

    $défaut  réduction par utilisation de la règle 1 (DEBUT)


état 110

   13 TYPE2: corechet_ouvr TYPE1 pnt_virgul entier_pos corechet_ferm . pnt_virgul

    pnt_virgul  décalage et aller à l'état 124


état 111

   22 AFFECTATION_TAB: corechet_ouvr entier_pos corechet_ferm AFFECTATION_NOR .

    $défaut  réduction par utilisation de la règle 22 (AFFECTATION_TAB)


état 112

   24 EXPRESSION: parenthese_ouvr EXPRESSION parenthese_ferm .

    $défaut  réduction par utilisation de la règle 24 (EXPRESSION)


état 113

   25 EXPRESSION: EXPRESSION . OPERATEUR_ARITHM EXPRESSION
   25           | EXPRESSION OPERATEUR_ARITHM EXPRESSION .

    add        décalage et aller à l'état 88
    soustract  décalage et aller à l'état 89
    division   décalage et aller à l'état 90
    multipl    décalage et aller à l'état 91

    add        [réduction par utilisation de la règle 25 (EXPRESSION)]
    soustract  [réduction par utilisation de la règle 25 (EXPRESSION)]
    division   [réduction par utilisation de la règle 25 (EXPRESSION)]
    multipl    [réduction par utilisation de la règle 25 (EXPRESSION)]
    $défaut    réduction par utilisation de la règle 25 (EXPRESSION)

    OPERATEUR_ARITHM  aller à l'état 92


état 114

   44 EXPRESSION_COND: OPERAND OPERATEUR_COND OPERAND .

    $défaut  réduction par utilisation de la règle 44 (EXPRESSION_COND)


état 115

   41 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm then . accolade_ouvr INSTRUCTIONS accolade_ferm SINON

    accolade_ouvr  décalage et aller à l'état 125


état 116

   45 EXPRESSION_COND: EXPRESSION_COND . and EXPRESSION_COND
   45                | EXPRESSION_COND and EXPRESSION_COND .
   46                | EXPRESSION_COND . or EXPRESSION_COND

    $défaut  réduction par utilisation de la règle 45 (EXPRESSION_COND)


état 117

   45 EXPRESSION_COND: EXPRESSION_COND . and EXPRESSION_COND
   46                | EXPRESSION_COND . or EXPRESSION_COND
   46                | EXPRESSION_COND or EXPRESSION_COND .

    and  décalage et aller à l'état 101

    $défaut  réduction par utilisation de la règle 46 (EXPRESSION_COND)


état 118

   35 INPUT: lire parenthese_ouvr idf parenthese_ferm pnt_virgul .

    $défaut  réduction par utilisation de la règle 35 (INPUT)


état 119

   40 DANS_OUTPUT: idf virgul DANS_OUTPUT .

    $défaut  réduction par utilisation de la règle 40 (DANS_OUTPUT)


état 120

   39 DANS_OUTPUT: chaine virgul DANS_OUTPUT .

    $défaut  réduction par utilisation de la règle 39 (DANS_OUTPUT)


état 121

   36 OUTPUT: output parenthese_ouvr DANS_OUTPUT parenthese_ferm pnt_virgul .

    $défaut  réduction par utilisation de la règle 36 (OUTPUT)


état 122

   54 LOOP_FOR: boucle_for idf from entier_pos to . entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    entier_pos  décalage et aller à l'état 126


état 123

   53 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while . parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul

    parenthese_ouvr  décalage et aller à l'état 127


état 124

   13 TYPE2: corechet_ouvr TYPE1 pnt_virgul entier_pos corechet_ferm pnt_virgul .

    $défaut  réduction par utilisation de la règle 13 (TYPE2)


état 125

   41 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm then accolade_ouvr . INSTRUCTIONS accolade_ferm SINON

    idf         décalage et aller à l'état 27
    if_cond     décalage et aller à l'état 28
    lire        décalage et aller à l'état 29
    output      décalage et aller à l'état 30
    boucle_for  décalage et aller à l'état 31
    boucle_do   décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 128
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 126

   54 LOOP_FOR: boucle_for idf from entier_pos to entier_pos . step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    step  décalage et aller à l'état 129


état 127

   53 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr . EXPRESSION_COND parenthese_ferm pnt_virgul

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62
    neg         décalage et aller à l'état 67

    VALEUR           aller à l'état 73
    OPERAND          aller à l'état 74
    EXPRESSION_COND  aller à l'état 130


état 128

   41 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm then accolade_ouvr INSTRUCTIONS . accolade_ferm SINON

    accolade_ferm  décalage et aller à l'état 131


état 129

   54 LOOP_FOR: boucle_for idf from entier_pos to entier_pos step . entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    entier_pos  décalage et aller à l'état 132


état 130

   45 EXPRESSION_COND: EXPRESSION_COND . and EXPRESSION_COND
   46                | EXPRESSION_COND . or EXPRESSION_COND
   53 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND . parenthese_ferm pnt_virgul

    parenthese_ferm  décalage et aller à l'état 133
    and              décalage et aller à l'état 101
    or               décalage et aller à l'état 102


état 131

   41 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm then accolade_ouvr INSTRUCTIONS accolade_ferm . SINON

    else_cond  décalage et aller à l'état 134

    $défaut  réduction par utilisation de la règle 43 (SINON)

    SINON  aller à l'état 135


état 132

   54 LOOP_FOR: boucle_for idf from entier_pos to entier_pos step entier_pos . accolade_ouvr INSTRUCTIONS accolade_ferm

    accolade_ouvr  décalage et aller à l'état 136


état 133

   53 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm . pnt_virgul

    pnt_virgul  décalage et aller à l'état 137


état 134

   42 SINON: else_cond . accolade_ouvr INSTRUCTIONS accolade_ferm

    accolade_ouvr  décalage et aller à l'état 138


état 135

   41 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm then accolade_ouvr INSTRUCTIONS accolade_ferm SINON .

    $défaut  réduction par utilisation de la règle 41 (CONDITION)


état 136

   54 LOOP_FOR: boucle_for idf from entier_pos to entier_pos step entier_pos accolade_ouvr . INSTRUCTIONS accolade_ferm

    idf         décalage et aller à l'état 27
    if_cond     décalage et aller à l'état 28
    lire        décalage et aller à l'état 29
    output      décalage et aller à l'état 30
    boucle_for  décalage et aller à l'état 31
    boucle_do   décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 139
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 137

   53 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul .

    $défaut  réduction par utilisation de la règle 53 (LOOP_DO)


état 138

   42 SINON: else_cond accolade_ouvr . INSTRUCTIONS accolade_ferm

    idf         décalage et aller à l'état 27
    if_cond     décalage et aller à l'état 28
    lire        décalage et aller à l'état 29
    output      décalage et aller à l'état 30
    boucle_for  décalage et aller à l'état 31
    boucle_do   décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 140
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 139

   54 LOOP_FOR: boucle_for idf from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS . accolade_ferm

    accolade_ferm  décalage et aller à l'état 141


état 140

   42 SINON: else_cond accolade_ouvr INSTRUCTIONS . accolade_ferm

    accolade_ferm  décalage et aller à l'état 142


état 141

   54 LOOP_FOR: boucle_for idf from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm .

    $défaut  réduction par utilisation de la règle 54 (LOOP_FOR)


état 142

   42 SINON: else_cond accolade_ouvr INSTRUCTIONS accolade_ferm .

    $défaut  réduction par utilisation de la règle 42 (SINON)
