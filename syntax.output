Terminals unused in grammar

   comment_une
   comment_plsr
   reel_pos
   reel_neg


État 10conflits: 1 décalage/réduction
État 34conflits: 6 décalage/réduction
État 35conflits: 6 décalage/réduction
État 36conflits: 6 décalage/réduction
État 37conflits: 6 décalage/réduction
État 38conflits: 6 décalage/réduction
État 45conflits: 6 décalage/réduction
État 46conflits: 6 décalage/réduction
État 115conflits: 2 décalage/réduction
État 116conflits: 2 décalage/réduction
État 125conflits: 6 décalage/réduction
État 128conflits: 1 décalage/réduction


Grammaire

    0 $accept: DEBUT $end

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    2 DECLARATION: let VARIABLE1 deux_pnts TYPE1 pnt_virgul
    3            | let idf deux_pnts TYPE2 pnt_virgul
    4            | const idf deux_pnts TYPE1 egal VALEUR

    5 VALEUR: entier_pos
    6       | entier_neg
    7       | float_pos
    8       | float_neg

    9 VARIABLE1: idf virgul VARIABLE1
   10          | idf

   11 TYPE1: float
   12      | int

   13 TYPE2: corechet_ouvr TYPE1 pnt_virgul entier_pos corechet_ferm pnt_virgul

   14 INSTRUCTIONS: /* vide */
   15             | idf AFFECTATION_NOR INSTRUCTIONS
   16             | idf AFFECTATION_TAB INSTRUCTIONS
   17             | INPUT INSTRUCTIONS
   18             | OUTPUT INSTRUCTIONS
   19             | CONDITION INSTRUCTIONS
   20             | LOOP_DO INSTRUCTIONS
   21             | LOOP_FOR INSTRUCTIONS

   22 AFFECTATION_TAB: corechet_ouvr entier_pos corechet_ferm AFFECTATION_NOR

   23 AFFECTATION_NOR: affect VALEUR pnt_virgul
   24                | affect EXPRESSION pnt_virgul

   25 EXPRESSION: OPERAND OPERATEUR_ARITHM OPERAND

   26 OPERAND: idf
   27        | VALEUR

   28 OPERATEUR_ARITHM: add
   29                 | soustract
   30                 | div
   31                 | multipl

   32 INPUT: input parenthese_ouvrante idf parenthese_fermante pnt_virgul

   33 OUTPUT: output parenthese_ouvrante DANS_OUTPUT parenthese_fermante pnt_virgul

   34 DANS_OUTPUT: chaine
   35            | idf
   36            | chaine virgul DANS_OUTPUT
   37            | idf virgul DANS_OUTPUT

   38 CONDITION: if parenthese_ouvrante EXPRESSION_COND parenthese_fermante then accolade_ouvr INSTRUCTIONS SINON

   39 SINON: else accolade_ouvr INSTRUCTIONS accolade_ferm
   40      | /* vide */

   41 EXPRESSION_COND: OPERAND OPERATEUR_COND OPERAND
   42                | neg OPERAND OPERATEUR_COND OPERAND
   43                | EXPRESSION_COND and EXPRESSION_COND
   44                | EXPRESSION_COND or EXPRESSION_COND

   45 OPERATEUR_COND: inf
   46               | sup
   47               | inf_ou_egal
   48               | sup_ou_egal
   49               | identiq
   50               | diff

   51 LOOP_DO: do accolade_ouvr INSTRUCTIONS accolade_ferm while EXPRESSION_COND pnt_virgul

   52 LOOP_FOR: for idf from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm


Terminaux, suivis des règles où ils apparaissent

$end (0) 0
error (256)
MainPrgm (258) 1
idf (259) 1 3 4 9 10 15 16 26 32 35 37 52
pnt_virgul (260) 1 2 3 13 23 24 32 33 51
var (261) 1
BeginPg (262) 1
accolade_ouvr (263) 1 38 39 51 52
accolade_ferm (264) 1 39 51 52
EndPg (265) 1
let (266) 2 3
deux_pnts (267) 2 3 4
const (268) 4
egal (269) 4
virgul (270) 9 36 37
float (271) 11
int (272) 12
entier_pos (273) 5 13 22 52
corechet_ouvr (274) 13 22
corechet_ferm (275) 13 22
entier_neg (276) 6
float_pos (277) 7
float_neg (278) 8
affect (279) 23 24
chaine (280) 34 36
if (281) 38
then (282) 38
parenthese_fermante (283) 32 33 38
parenthese_ouvrante (284) 32 33 38
input (285) 32
output (286) 33
add (287) 28
soustract (288) 29
div (289) 30
multipl (290) 31
inf (291) 45
sup (292) 46
inf_ou_egal (293) 47
sup_ou_egal (294) 48
neg (295) 42
and (296) 43
or (297) 44
diff (298) 50
for (299) 52
from (300) 52
to (301) 52
step (302) 52
do (303) 51
while (304) 51
comment_une (305)
comment_plsr (306)
else (307) 39
reel_pos (308)
reel_neg (309)
identiq (310) 49


Non-terminaux, suivis des règles où ils apparaissent

$accept (56)
    à gauche: 0
DEBUT (57)
    à gauche: 1, à droite: 0
DECLARATION (58)
    à gauche: 2 3 4, à droite: 1
VALEUR (59)
    à gauche: 5 6 7 8, à droite: 4 23 27
VARIABLE1 (60)
    à gauche: 9 10, à droite: 2 9
TYPE1 (61)
    à gauche: 11 12, à droite: 2 4 13
TYPE2 (62)
    à gauche: 13, à droite: 3
INSTRUCTIONS (63)
    à gauche: 14 15 16 17 18 19 20 21, à droite: 1 15 16 17 18 19 20
    21 38 39 51 52
AFFECTATION_TAB (64)
    à gauche: 22, à droite: 16
AFFECTATION_NOR (65)
    à gauche: 23 24, à droite: 15 22
EXPRESSION (66)
    à gauche: 25, à droite: 24
OPERAND (67)
    à gauche: 26 27, à droite: 25 41 42
OPERATEUR_ARITHM (68)
    à gauche: 28 29 30 31, à droite: 25
INPUT (69)
    à gauche: 32, à droite: 17
OUTPUT (70)
    à gauche: 33, à droite: 18
DANS_OUTPUT (71)
    à gauche: 34 35 36 37, à droite: 33 36 37
CONDITION (72)
    à gauche: 38, à droite: 19
SINON (73)
    à gauche: 39 40, à droite: 38
EXPRESSION_COND (74)
    à gauche: 41 42 43 44, à droite: 38 43 44 51
OPERATEUR_COND (75)
    à gauche: 45 46 47 48 49 50, à droite: 41 42
LOOP_DO (76)
    à gauche: 51, à droite: 20
LOOP_FOR (77)
    à gauche: 52, à droite: 21


état 0

    0 $accept: . DEBUT $end

    MainPrgm  décalage et aller à l'état 1

    DEBUT  aller à l'état 2


état 1

    1 DEBUT: MainPrgm . idf pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    idf  décalage et aller à l'état 3


état 2

    0 $accept: DEBUT . $end

    $end  décalage et aller à l'état 4


état 3

    1 DEBUT: MainPrgm idf . pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    pnt_virgul  décalage et aller à l'état 5


état 4

    0 $accept: DEBUT $end .

    $défaut  accepter


état 5

    1 DEBUT: MainPrgm idf pnt_virgul . var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    var  décalage et aller à l'état 6


état 6

    1 DEBUT: MainPrgm idf pnt_virgul var . DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    let    décalage et aller à l'état 7
    const  décalage et aller à l'état 8

    DECLARATION  aller à l'état 9


état 7

    2 DECLARATION: let . VARIABLE1 deux_pnts TYPE1 pnt_virgul
    3            | let . idf deux_pnts TYPE2 pnt_virgul

    idf  décalage et aller à l'état 10

    VARIABLE1  aller à l'état 11


état 8

    4 DECLARATION: const . idf deux_pnts TYPE1 egal VALEUR

    idf  décalage et aller à l'état 12


état 9

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION . BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    BeginPg  décalage et aller à l'état 13


état 10

    3 DECLARATION: let idf . deux_pnts TYPE2 pnt_virgul
    9 VARIABLE1: idf . virgul VARIABLE1
   10          | idf .

    deux_pnts  décalage et aller à l'état 14
    virgul     décalage et aller à l'état 15

    deux_pnts  [réduction par utilisation de la règle 10 (VARIABLE1)]


état 11

    2 DECLARATION: let VARIABLE1 . deux_pnts TYPE1 pnt_virgul

    deux_pnts  décalage et aller à l'état 16


état 12

    4 DECLARATION: const idf . deux_pnts TYPE1 egal VALEUR

    deux_pnts  décalage et aller à l'état 17


état 13

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg . accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    accolade_ouvr  décalage et aller à l'état 18


état 14

    3 DECLARATION: let idf deux_pnts . TYPE2 pnt_virgul

    corechet_ouvr  décalage et aller à l'état 19

    TYPE2  aller à l'état 20


état 15

    9 VARIABLE1: idf virgul . VARIABLE1

    idf  décalage et aller à l'état 21

    VARIABLE1  aller à l'état 22


état 16

    2 DECLARATION: let VARIABLE1 deux_pnts . TYPE1 pnt_virgul

    float  décalage et aller à l'état 23
    int    décalage et aller à l'état 24

    TYPE1  aller à l'état 25


état 17

    4 DECLARATION: const idf deux_pnts . TYPE1 egal VALEUR

    float  décalage et aller à l'état 23
    int    décalage et aller à l'état 24

    TYPE1  aller à l'état 26


état 18

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg accolade_ouvr . INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    idf     décalage et aller à l'état 27
    if      décalage et aller à l'état 28
    input   décalage et aller à l'état 29
    output  décalage et aller à l'état 30
    for     décalage et aller à l'état 31
    do      décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 33
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 19

   13 TYPE2: corechet_ouvr . TYPE1 pnt_virgul entier_pos corechet_ferm pnt_virgul

    float  décalage et aller à l'état 23
    int    décalage et aller à l'état 24

    TYPE1  aller à l'état 39


état 20

    3 DECLARATION: let idf deux_pnts TYPE2 . pnt_virgul

    pnt_virgul  décalage et aller à l'état 40


état 21

    9 VARIABLE1: idf . virgul VARIABLE1
   10          | idf .

    virgul  décalage et aller à l'état 15

    $défaut  réduction par utilisation de la règle 10 (VARIABLE1)


état 22

    9 VARIABLE1: idf virgul VARIABLE1 .

    $défaut  réduction par utilisation de la règle 9 (VARIABLE1)


état 23

   11 TYPE1: float .

    $défaut  réduction par utilisation de la règle 11 (TYPE1)


état 24

   12 TYPE1: int .

    $défaut  réduction par utilisation de la règle 12 (TYPE1)


état 25

    2 DECLARATION: let VARIABLE1 deux_pnts TYPE1 . pnt_virgul

    pnt_virgul  décalage et aller à l'état 41


état 26

    4 DECLARATION: const idf deux_pnts TYPE1 . egal VALEUR

    egal  décalage et aller à l'état 42


état 27

   15 INSTRUCTIONS: idf . AFFECTATION_NOR INSTRUCTIONS
   16             | idf . AFFECTATION_TAB INSTRUCTIONS

    corechet_ouvr  décalage et aller à l'état 43
    affect         décalage et aller à l'état 44

    AFFECTATION_TAB  aller à l'état 45
    AFFECTATION_NOR  aller à l'état 46


état 28

   38 CONDITION: if . parenthese_ouvrante EXPRESSION_COND parenthese_fermante then accolade_ouvr INSTRUCTIONS SINON

    parenthese_ouvrante  décalage et aller à l'état 47


état 29

   32 INPUT: input . parenthese_ouvrante idf parenthese_fermante pnt_virgul

    parenthese_ouvrante  décalage et aller à l'état 48


état 30

   33 OUTPUT: output . parenthese_ouvrante DANS_OUTPUT parenthese_fermante pnt_virgul

    parenthese_ouvrante  décalage et aller à l'état 49


état 31

   52 LOOP_FOR: for . idf from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    idf  décalage et aller à l'état 50


état 32

   51 LOOP_DO: do . accolade_ouvr INSTRUCTIONS accolade_ferm while EXPRESSION_COND pnt_virgul

    accolade_ouvr  décalage et aller à l'état 51


état 33

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS . accolade_ferm EndPg pnt_virgul

    accolade_ferm  décalage et aller à l'état 52


état 34

   17 INSTRUCTIONS: INPUT . INSTRUCTIONS

    idf     décalage et aller à l'état 27
    if      décalage et aller à l'état 28
    input   décalage et aller à l'état 29
    output  décalage et aller à l'état 30
    for     décalage et aller à l'état 31
    do      décalage et aller à l'état 32

    idf      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    if       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    input    [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    output   [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    for      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    do       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 53
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 35

   18 INSTRUCTIONS: OUTPUT . INSTRUCTIONS

    idf     décalage et aller à l'état 27
    if      décalage et aller à l'état 28
    input   décalage et aller à l'état 29
    output  décalage et aller à l'état 30
    for     décalage et aller à l'état 31
    do      décalage et aller à l'état 32

    idf      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    if       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    input    [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    output   [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    for      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    do       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 54
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 36

   19 INSTRUCTIONS: CONDITION . INSTRUCTIONS

    idf     décalage et aller à l'état 27
    if      décalage et aller à l'état 28
    input   décalage et aller à l'état 29
    output  décalage et aller à l'état 30
    for     décalage et aller à l'état 31
    do      décalage et aller à l'état 32

    idf      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    if       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    input    [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    output   [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    for      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    do       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 55
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 37

   20 INSTRUCTIONS: LOOP_DO . INSTRUCTIONS

    idf     décalage et aller à l'état 27
    if      décalage et aller à l'état 28
    input   décalage et aller à l'état 29
    output  décalage et aller à l'état 30
    for     décalage et aller à l'état 31
    do      décalage et aller à l'état 32

    idf      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    if       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    input    [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    output   [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    for      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    do       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 56
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 38

   21 INSTRUCTIONS: LOOP_FOR . INSTRUCTIONS

    idf     décalage et aller à l'état 27
    if      décalage et aller à l'état 28
    input   décalage et aller à l'état 29
    output  décalage et aller à l'état 30
    for     décalage et aller à l'état 31
    do      décalage et aller à l'état 32

    idf      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    if       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    input    [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    output   [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    for      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    do       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 57
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 39

   13 TYPE2: corechet_ouvr TYPE1 . pnt_virgul entier_pos corechet_ferm pnt_virgul

    pnt_virgul  décalage et aller à l'état 58


état 40

    3 DECLARATION: let idf deux_pnts TYPE2 pnt_virgul .

    $défaut  réduction par utilisation de la règle 3 (DECLARATION)


état 41

    2 DECLARATION: let VARIABLE1 deux_pnts TYPE1 pnt_virgul .

    $défaut  réduction par utilisation de la règle 2 (DECLARATION)


état 42

    4 DECLARATION: const idf deux_pnts TYPE1 egal . VALEUR

    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62

    VALEUR  aller à l'état 63


état 43

   22 AFFECTATION_TAB: corechet_ouvr . entier_pos corechet_ferm AFFECTATION_NOR

    entier_pos  décalage et aller à l'état 64


état 44

   23 AFFECTATION_NOR: affect . VALEUR pnt_virgul
   24                | affect . EXPRESSION pnt_virgul

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62

    VALEUR      aller à l'état 66
    EXPRESSION  aller à l'état 67
    OPERAND     aller à l'état 68


état 45

   16 INSTRUCTIONS: idf AFFECTATION_TAB . INSTRUCTIONS

    idf     décalage et aller à l'état 27
    if      décalage et aller à l'état 28
    input   décalage et aller à l'état 29
    output  décalage et aller à l'état 30
    for     décalage et aller à l'état 31
    do      décalage et aller à l'état 32

    idf      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    if       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    input    [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    output   [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    for      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    do       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 69
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 46

   15 INSTRUCTIONS: idf AFFECTATION_NOR . INSTRUCTIONS

    idf     décalage et aller à l'état 27
    if      décalage et aller à l'état 28
    input   décalage et aller à l'état 29
    output  décalage et aller à l'état 30
    for     décalage et aller à l'état 31
    do      décalage et aller à l'état 32

    idf      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    if       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    input    [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    output   [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    for      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    do       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 70
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 47

   38 CONDITION: if parenthese_ouvrante . EXPRESSION_COND parenthese_fermante then accolade_ouvr INSTRUCTIONS SINON

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62
    neg         décalage et aller à l'état 71

    VALEUR           aller à l'état 72
    OPERAND          aller à l'état 73
    EXPRESSION_COND  aller à l'état 74


état 48

   32 INPUT: input parenthese_ouvrante . idf parenthese_fermante pnt_virgul

    idf  décalage et aller à l'état 75


état 49

   33 OUTPUT: output parenthese_ouvrante . DANS_OUTPUT parenthese_fermante pnt_virgul

    idf     décalage et aller à l'état 76
    chaine  décalage et aller à l'état 77

    DANS_OUTPUT  aller à l'état 78


état 50

   52 LOOP_FOR: for idf . from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    from  décalage et aller à l'état 79


état 51

   51 LOOP_DO: do accolade_ouvr . INSTRUCTIONS accolade_ferm while EXPRESSION_COND pnt_virgul

    idf     décalage et aller à l'état 27
    if      décalage et aller à l'état 28
    input   décalage et aller à l'état 29
    output  décalage et aller à l'état 30
    for     décalage et aller à l'état 31
    do      décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 80
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 52

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm . EndPg pnt_virgul

    EndPg  décalage et aller à l'état 81


état 53

   17 INSTRUCTIONS: INPUT INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 17 (INSTRUCTIONS)


état 54

   18 INSTRUCTIONS: OUTPUT INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 18 (INSTRUCTIONS)


état 55

   19 INSTRUCTIONS: CONDITION INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 19 (INSTRUCTIONS)


état 56

   20 INSTRUCTIONS: LOOP_DO INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 20 (INSTRUCTIONS)


état 57

   21 INSTRUCTIONS: LOOP_FOR INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 21 (INSTRUCTIONS)


état 58

   13 TYPE2: corechet_ouvr TYPE1 pnt_virgul . entier_pos corechet_ferm pnt_virgul

    entier_pos  décalage et aller à l'état 82


état 59

    5 VALEUR: entier_pos .

    $défaut  réduction par utilisation de la règle 5 (VALEUR)


état 60

    6 VALEUR: entier_neg .

    $défaut  réduction par utilisation de la règle 6 (VALEUR)


état 61

    7 VALEUR: float_pos .

    $défaut  réduction par utilisation de la règle 7 (VALEUR)


état 62

    8 VALEUR: float_neg .

    $défaut  réduction par utilisation de la règle 8 (VALEUR)


état 63

    4 DECLARATION: const idf deux_pnts TYPE1 egal VALEUR .

    $défaut  réduction par utilisation de la règle 4 (DECLARATION)


état 64

   22 AFFECTATION_TAB: corechet_ouvr entier_pos . corechet_ferm AFFECTATION_NOR

    corechet_ferm  décalage et aller à l'état 83


état 65

   26 OPERAND: idf .

    $défaut  réduction par utilisation de la règle 26 (OPERAND)


état 66

   23 AFFECTATION_NOR: affect VALEUR . pnt_virgul
   27 OPERAND: VALEUR .

    pnt_virgul  décalage et aller à l'état 84

    $défaut  réduction par utilisation de la règle 27 (OPERAND)


état 67

   24 AFFECTATION_NOR: affect EXPRESSION . pnt_virgul

    pnt_virgul  décalage et aller à l'état 85


état 68

   25 EXPRESSION: OPERAND . OPERATEUR_ARITHM OPERAND

    add        décalage et aller à l'état 86
    soustract  décalage et aller à l'état 87
    div        décalage et aller à l'état 88
    multipl    décalage et aller à l'état 89

    OPERATEUR_ARITHM  aller à l'état 90


état 69

   16 INSTRUCTIONS: idf AFFECTATION_TAB INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)


état 70

   15 INSTRUCTIONS: idf AFFECTATION_NOR INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 15 (INSTRUCTIONS)


état 71

   42 EXPRESSION_COND: neg . OPERAND OPERATEUR_COND OPERAND

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62

    VALEUR   aller à l'état 72
    OPERAND  aller à l'état 91


état 72

   27 OPERAND: VALEUR .

    $défaut  réduction par utilisation de la règle 27 (OPERAND)


état 73

   41 EXPRESSION_COND: OPERAND . OPERATEUR_COND OPERAND

    inf          décalage et aller à l'état 92
    sup          décalage et aller à l'état 93
    inf_ou_egal  décalage et aller à l'état 94
    sup_ou_egal  décalage et aller à l'état 95
    diff         décalage et aller à l'état 96
    identiq      décalage et aller à l'état 97

    OPERATEUR_COND  aller à l'état 98


état 74

   38 CONDITION: if parenthese_ouvrante EXPRESSION_COND . parenthese_fermante then accolade_ouvr INSTRUCTIONS SINON
   43 EXPRESSION_COND: EXPRESSION_COND . and EXPRESSION_COND
   44                | EXPRESSION_COND . or EXPRESSION_COND

    parenthese_fermante  décalage et aller à l'état 99
    and                  décalage et aller à l'état 100
    or                   décalage et aller à l'état 101


état 75

   32 INPUT: input parenthese_ouvrante idf . parenthese_fermante pnt_virgul

    parenthese_fermante  décalage et aller à l'état 102


état 76

   35 DANS_OUTPUT: idf .
   37            | idf . virgul DANS_OUTPUT

    virgul  décalage et aller à l'état 103

    $défaut  réduction par utilisation de la règle 35 (DANS_OUTPUT)


état 77

   34 DANS_OUTPUT: chaine .
   36            | chaine . virgul DANS_OUTPUT

    virgul  décalage et aller à l'état 104

    $défaut  réduction par utilisation de la règle 34 (DANS_OUTPUT)


état 78

   33 OUTPUT: output parenthese_ouvrante DANS_OUTPUT . parenthese_fermante pnt_virgul

    parenthese_fermante  décalage et aller à l'état 105


état 79

   52 LOOP_FOR: for idf from . entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    entier_pos  décalage et aller à l'état 106


état 80

   51 LOOP_DO: do accolade_ouvr INSTRUCTIONS . accolade_ferm while EXPRESSION_COND pnt_virgul

    accolade_ferm  décalage et aller à l'état 107


état 81

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg . pnt_virgul

    pnt_virgul  décalage et aller à l'état 108


état 82

   13 TYPE2: corechet_ouvr TYPE1 pnt_virgul entier_pos . corechet_ferm pnt_virgul

    corechet_ferm  décalage et aller à l'état 109


état 83

   22 AFFECTATION_TAB: corechet_ouvr entier_pos corechet_ferm . AFFECTATION_NOR

    affect  décalage et aller à l'état 44

    AFFECTATION_NOR  aller à l'état 110


état 84

   23 AFFECTATION_NOR: affect VALEUR pnt_virgul .

    $défaut  réduction par utilisation de la règle 23 (AFFECTATION_NOR)


état 85

   24 AFFECTATION_NOR: affect EXPRESSION pnt_virgul .

    $défaut  réduction par utilisation de la règle 24 (AFFECTATION_NOR)


état 86

   28 OPERATEUR_ARITHM: add .

    $défaut  réduction par utilisation de la règle 28 (OPERATEUR_ARITHM)


état 87

   29 OPERATEUR_ARITHM: soustract .

    $défaut  réduction par utilisation de la règle 29 (OPERATEUR_ARITHM)


état 88

   30 OPERATEUR_ARITHM: div .

    $défaut  réduction par utilisation de la règle 30 (OPERATEUR_ARITHM)


état 89

   31 OPERATEUR_ARITHM: multipl .

    $défaut  réduction par utilisation de la règle 31 (OPERATEUR_ARITHM)


état 90

   25 EXPRESSION: OPERAND OPERATEUR_ARITHM . OPERAND

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62

    VALEUR   aller à l'état 72
    OPERAND  aller à l'état 111


état 91

   42 EXPRESSION_COND: neg OPERAND . OPERATEUR_COND OPERAND

    inf          décalage et aller à l'état 92
    sup          décalage et aller à l'état 93
    inf_ou_egal  décalage et aller à l'état 94
    sup_ou_egal  décalage et aller à l'état 95
    diff         décalage et aller à l'état 96
    identiq      décalage et aller à l'état 97

    OPERATEUR_COND  aller à l'état 112


état 92

   45 OPERATEUR_COND: inf .

    $défaut  réduction par utilisation de la règle 45 (OPERATEUR_COND)


état 93

   46 OPERATEUR_COND: sup .

    $défaut  réduction par utilisation de la règle 46 (OPERATEUR_COND)


état 94

   47 OPERATEUR_COND: inf_ou_egal .

    $défaut  réduction par utilisation de la règle 47 (OPERATEUR_COND)


état 95

   48 OPERATEUR_COND: sup_ou_egal .

    $défaut  réduction par utilisation de la règle 48 (OPERATEUR_COND)


état 96

   50 OPERATEUR_COND: diff .

    $défaut  réduction par utilisation de la règle 50 (OPERATEUR_COND)


état 97

   49 OPERATEUR_COND: identiq .

    $défaut  réduction par utilisation de la règle 49 (OPERATEUR_COND)


état 98

   41 EXPRESSION_COND: OPERAND OPERATEUR_COND . OPERAND

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62

    VALEUR   aller à l'état 72
    OPERAND  aller à l'état 113


état 99

   38 CONDITION: if parenthese_ouvrante EXPRESSION_COND parenthese_fermante . then accolade_ouvr INSTRUCTIONS SINON

    then  décalage et aller à l'état 114


état 100

   43 EXPRESSION_COND: EXPRESSION_COND and . EXPRESSION_COND

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62
    neg         décalage et aller à l'état 71

    VALEUR           aller à l'état 72
    OPERAND          aller à l'état 73
    EXPRESSION_COND  aller à l'état 115


état 101

   44 EXPRESSION_COND: EXPRESSION_COND or . EXPRESSION_COND

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62
    neg         décalage et aller à l'état 71

    VALEUR           aller à l'état 72
    OPERAND          aller à l'état 73
    EXPRESSION_COND  aller à l'état 116


état 102

   32 INPUT: input parenthese_ouvrante idf parenthese_fermante . pnt_virgul

    pnt_virgul  décalage et aller à l'état 117


état 103

   37 DANS_OUTPUT: idf virgul . DANS_OUTPUT

    idf     décalage et aller à l'état 76
    chaine  décalage et aller à l'état 77

    DANS_OUTPUT  aller à l'état 118


état 104

   36 DANS_OUTPUT: chaine virgul . DANS_OUTPUT

    idf     décalage et aller à l'état 76
    chaine  décalage et aller à l'état 77

    DANS_OUTPUT  aller à l'état 119


état 105

   33 OUTPUT: output parenthese_ouvrante DANS_OUTPUT parenthese_fermante . pnt_virgul

    pnt_virgul  décalage et aller à l'état 120


état 106

   52 LOOP_FOR: for idf from entier_pos . to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    to  décalage et aller à l'état 121


état 107

   51 LOOP_DO: do accolade_ouvr INSTRUCTIONS accolade_ferm . while EXPRESSION_COND pnt_virgul

    while  décalage et aller à l'état 122


état 108

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul .

    $défaut  réduction par utilisation de la règle 1 (DEBUT)


état 109

   13 TYPE2: corechet_ouvr TYPE1 pnt_virgul entier_pos corechet_ferm . pnt_virgul

    pnt_virgul  décalage et aller à l'état 123


état 110

   22 AFFECTATION_TAB: corechet_ouvr entier_pos corechet_ferm AFFECTATION_NOR .

    $défaut  réduction par utilisation de la règle 22 (AFFECTATION_TAB)


état 111

   25 EXPRESSION: OPERAND OPERATEUR_ARITHM OPERAND .

    $défaut  réduction par utilisation de la règle 25 (EXPRESSION)


état 112

   42 EXPRESSION_COND: neg OPERAND OPERATEUR_COND . OPERAND

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62

    VALEUR   aller à l'état 72
    OPERAND  aller à l'état 124


état 113

   41 EXPRESSION_COND: OPERAND OPERATEUR_COND OPERAND .

    $défaut  réduction par utilisation de la règle 41 (EXPRESSION_COND)


état 114

   38 CONDITION: if parenthese_ouvrante EXPRESSION_COND parenthese_fermante then . accolade_ouvr INSTRUCTIONS SINON

    accolade_ouvr  décalage et aller à l'état 125


état 115

   43 EXPRESSION_COND: EXPRESSION_COND . and EXPRESSION_COND
   43                | EXPRESSION_COND and EXPRESSION_COND .
   44                | EXPRESSION_COND . or EXPRESSION_COND

    and  décalage et aller à l'état 100
    or   décalage et aller à l'état 101

    and      [réduction par utilisation de la règle 43 (EXPRESSION_COND)]
    or       [réduction par utilisation de la règle 43 (EXPRESSION_COND)]
    $défaut  réduction par utilisation de la règle 43 (EXPRESSION_COND)


état 116

   43 EXPRESSION_COND: EXPRESSION_COND . and EXPRESSION_COND
   44                | EXPRESSION_COND . or EXPRESSION_COND
   44                | EXPRESSION_COND or EXPRESSION_COND .

    and  décalage et aller à l'état 100
    or   décalage et aller à l'état 101

    and      [réduction par utilisation de la règle 44 (EXPRESSION_COND)]
    or       [réduction par utilisation de la règle 44 (EXPRESSION_COND)]
    $défaut  réduction par utilisation de la règle 44 (EXPRESSION_COND)


état 117

   32 INPUT: input parenthese_ouvrante idf parenthese_fermante pnt_virgul .

    $défaut  réduction par utilisation de la règle 32 (INPUT)


état 118

   37 DANS_OUTPUT: idf virgul DANS_OUTPUT .

    $défaut  réduction par utilisation de la règle 37 (DANS_OUTPUT)


état 119

   36 DANS_OUTPUT: chaine virgul DANS_OUTPUT .

    $défaut  réduction par utilisation de la règle 36 (DANS_OUTPUT)


état 120

   33 OUTPUT: output parenthese_ouvrante DANS_OUTPUT parenthese_fermante pnt_virgul .

    $défaut  réduction par utilisation de la règle 33 (OUTPUT)


état 121

   52 LOOP_FOR: for idf from entier_pos to . entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    entier_pos  décalage et aller à l'état 126


état 122

   51 LOOP_DO: do accolade_ouvr INSTRUCTIONS accolade_ferm while . EXPRESSION_COND pnt_virgul

    idf         décalage et aller à l'état 65
    entier_pos  décalage et aller à l'état 59
    entier_neg  décalage et aller à l'état 60
    float_pos   décalage et aller à l'état 61
    float_neg   décalage et aller à l'état 62
    neg         décalage et aller à l'état 71

    VALEUR           aller à l'état 72
    OPERAND          aller à l'état 73
    EXPRESSION_COND  aller à l'état 127


état 123

   13 TYPE2: corechet_ouvr TYPE1 pnt_virgul entier_pos corechet_ferm pnt_virgul .

    $défaut  réduction par utilisation de la règle 13 (TYPE2)


état 124

   42 EXPRESSION_COND: neg OPERAND OPERATEUR_COND OPERAND .

    $défaut  réduction par utilisation de la règle 42 (EXPRESSION_COND)


état 125

   38 CONDITION: if parenthese_ouvrante EXPRESSION_COND parenthese_fermante then accolade_ouvr . INSTRUCTIONS SINON

    idf     décalage et aller à l'état 27
    if      décalage et aller à l'état 28
    input   décalage et aller à l'état 29
    output  décalage et aller à l'état 30
    for     décalage et aller à l'état 31
    do      décalage et aller à l'état 32

    idf      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    if       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    input    [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    output   [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    for      [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    do       [réduction par utilisation de la règle 14 (INSTRUCTIONS)]
    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 128
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 126

   52 LOOP_FOR: for idf from entier_pos to entier_pos . step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    step  décalage et aller à l'état 129


état 127

   43 EXPRESSION_COND: EXPRESSION_COND . and EXPRESSION_COND
   44                | EXPRESSION_COND . or EXPRESSION_COND
   51 LOOP_DO: do accolade_ouvr INSTRUCTIONS accolade_ferm while EXPRESSION_COND . pnt_virgul

    pnt_virgul  décalage et aller à l'état 130
    and         décalage et aller à l'état 100
    or          décalage et aller à l'état 101


état 128

   38 CONDITION: if parenthese_ouvrante EXPRESSION_COND parenthese_fermante then accolade_ouvr INSTRUCTIONS . SINON

    else  décalage et aller à l'état 131

    else     [réduction par utilisation de la règle 40 (SINON)]
    $défaut  réduction par utilisation de la règle 40 (SINON)

    SINON  aller à l'état 132


état 129

   52 LOOP_FOR: for idf from entier_pos to entier_pos step . entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    entier_pos  décalage et aller à l'état 133


état 130

   51 LOOP_DO: do accolade_ouvr INSTRUCTIONS accolade_ferm while EXPRESSION_COND pnt_virgul .

    $défaut  réduction par utilisation de la règle 51 (LOOP_DO)


état 131

   39 SINON: else . accolade_ouvr INSTRUCTIONS accolade_ferm

    accolade_ouvr  décalage et aller à l'état 134


état 132

   38 CONDITION: if parenthese_ouvrante EXPRESSION_COND parenthese_fermante then accolade_ouvr INSTRUCTIONS SINON .

    $défaut  réduction par utilisation de la règle 38 (CONDITION)


état 133

   52 LOOP_FOR: for idf from entier_pos to entier_pos step entier_pos . accolade_ouvr INSTRUCTIONS accolade_ferm

    accolade_ouvr  décalage et aller à l'état 135


état 134

   39 SINON: else accolade_ouvr . INSTRUCTIONS accolade_ferm

    idf     décalage et aller à l'état 27
    if      décalage et aller à l'état 28
    input   décalage et aller à l'état 29
    output  décalage et aller à l'état 30
    for     décalage et aller à l'état 31
    do      décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 136
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 135

   52 LOOP_FOR: for idf from entier_pos to entier_pos step entier_pos accolade_ouvr . INSTRUCTIONS accolade_ferm

    idf     décalage et aller à l'état 27
    if      décalage et aller à l'état 28
    input   décalage et aller à l'état 29
    output  décalage et aller à l'état 30
    for     décalage et aller à l'état 31
    do      décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 14 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 137
    INPUT         aller à l'état 34
    OUTPUT        aller à l'état 35
    CONDITION     aller à l'état 36
    LOOP_DO       aller à l'état 37
    LOOP_FOR      aller à l'état 38


état 136

   39 SINON: else accolade_ouvr INSTRUCTIONS . accolade_ferm

    accolade_ferm  décalage et aller à l'état 138


état 137

   52 LOOP_FOR: for idf from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS . accolade_ferm

    accolade_ferm  décalage et aller à l'état 139


état 138

   39 SINON: else accolade_ouvr INSTRUCTIONS accolade_ferm .

    $défaut  réduction par utilisation de la règle 39 (SINON)


état 139

   52 LOOP_FOR: for idf from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm .

    $défaut  réduction par utilisation de la règle 52 (LOOP_FOR)
